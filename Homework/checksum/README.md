# checksum

## 题目描述

这一题要求你进行 IP 分组头部校验和验证，请你修改 `checksum.cpp` 文件，实现这样的一个函数：

```cpp
// 函数注释见代码
bool validateIPChecksum(unsigned char *packet, unsigned long len) {
    // TODO
    return true;
}
```

IP 分组头部校验和的计算方式如下：

1. 将分组头中的校验和字段填充为 0
2. 将整个分组头视作大端序 16 位整数的数组，将所有 16 位整数相加
3. 如果和发生溢出，则将其截断为低 16 位及溢出部分，然后将溢出部分加到低 16 位
   (如 0x1CB2F -> 0xCB2F + 0x1)
4. 如果上述操作中又发生了溢出，则重复上述操作，直到不发生溢出
5. 将得到的结果按位取反，使用大端序填充到校验和字段

本题目中要求的是校验和的验证。验证的一种方法是计算出正确的校验和，然后与输入的校验和比较。然而，RFC 1071 推荐的方法是用类似的算法计算整个分组头部（包含校验和字段本身）的反码和，然后与 `0xFFFF` 比较。你也可以用其它 **等价** 的方法实现。

你不需要处理输入输出，你只需要在本地执行 `make grade` 就可以进行本地评测。在本题中，保证 IP 头里只有 `Checksum` 可能是不合法的。请注意处理 `IHL` 不等于 5 的情况。

## 样例 2

见 data 目录下的 *checksum_input2.pcap* 与 *checksum_output2.out*。

`checksum_input2.pcap` 是一个 PCAP 格式的文件，你可以用 Wireshark 软件打开它。

## 样例 2 解释

可以看到这个 PCAP 中一共有 10 个 IP 包，其中第 3 5 7 10 个的校验和是正确的，其余是错误的。输出文件的每一行对应一个 IP 包，`Yes` 表示校验和正确， `No` 表示校验和错误。
